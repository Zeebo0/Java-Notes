# Java 多线程

## 线程&进程

### 什么是进程？

进程时程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序，就是一个进程从创建、运行到消亡的过程。

在 Java 中，当我们启动 main 函数时，其实就是启动了一个 JVM 进程，而 main 函数所在的线程就是这个进程中的主线程。

### 什么是线程？

线程和进程相似，但线程是一个比进程更小的执行单位。一个进程在执行过程中，可以产生多个线程。与进程不同的是**同类的多个线程共享进程的 堆 和 方法区 的资源**，但每个线程都有自己的 **程序计数器、虚拟机栈 和 本地方法栈**，所以系统在产生一个线程或者在多个线程之间切换时，负担要比进程小很多，因此，线程被称为 **轻量级的进程**。

> **一个 Java 程序的运行是 main 线程和多个其他线程同时运行**

## 线程和进程的关系和区别，以及各自的优缺点

### Java 内存区域

Java 虚拟机在执行 Java 程序过程中会把它管理的内存划分称为若干个不同的数据区域，这些组成部分一些是线程私有的，其他的则是线程共享的。

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存

#### 程序计数器

程序计数器的主要有两个作用：

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，例如：顺序执行、选择、循环、异常处理等操作
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候，虚拟机能够知道上次执行到哪里

> **程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程创建而被创建，随着线程的结束而死亡**

**程序计数器为什么是私有的？**

程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

#### 虚拟机栈

**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**JVM 会出现两种异常：**

- **StackOverFlowError：**若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机的栈的最大深度的时候，就会抛出该异常。
- **OutOfMemoryError:** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时用完了，无法再动态扩展了，此时会抛出该异常。

> **Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。**

#### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

**虚拟机栈和本地方法栈为什么是私有的？**

- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

#### 堆

堆 是 Java 虚拟机所管理的内存中最大的一块区域，是所有线程共享的，在虚拟器启动时就创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都存放在这里**

堆 是垃圾回收器管理的主要区域，因此也被称作为 **GC堆**。堆 还可以细分为 **新生代** 和 **老生代** 

进一步划分的目的就是为了更好地回收内存空间，更快地分配内存。

> **JDK 1.8 中移除了永久代，取而代之的是一个叫元空间的区域，永久代使用的是堆内存的空间，而元空间使用的是物理内存，直接受到本机的物理内存的限制**

#### 方法区

**方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。**

> **相对而言，垃圾回收在这个区域较少出现，但不意味着进入了方法区后就会永久存在**

#### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK 1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

#### 直接内存

JDK 1.4中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

#### 总结

线程是进程划分成更小的运行单位，线程和进程最大的不同在于基本上各进程都是相互独立的，但是同一进程的不同线程之间，可能会相互影响。线程的执行开销较小，但是管理和维护较为困难，进程恰好与之相反。

堆 和 方法区 是所有线程共享的资源，其中 堆 是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要存放已被加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据。

## 并发 & 并行

- **并发：**同一时间段内，多个任务都在执行
- **并行：**单位时间内，多个任务同时执行

## 多线程带来的问题？

并发编程的目的是为了提高程序执行的效率和运行速度，但是并发编程并不是总能提高程序的的执行速度，而且有可能带来内存泄漏、死锁、线程不安全等问题。

## 线程的声明周期和状态

|   状态名称   | 说明                                                         |
| :----------: | :----------------------------------------------------------- |
|     new      | 初始状态，线程被构建，但是还没有调用 start 方法              |
|   runnable   | 运行状态，Java 线程将操作系统中就绪和运行的两种状态统称为运行中 |
|   blocked    | 阻塞状态，表示线程阻塞于锁                                   |
|   waiting    | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出特定动作 |
| time_waiting | 超时等待状态，不同意等待状态，可以在指定时间自行返回         |
|  terminated  | 终止状态，表示当前线程已经执行完毕                           |

线程创建之后处理**new**状态，调用start方法开始运行，线程这时候处于**ready**状态，可运行状态的线程或者CPU时间片之后就处于**running**状态。当线程执行wait方法之后，线程进入**waiting**状态，进入等待转台的线程，需要依靠其他线程的通知，才能进入运行状态，而**time_waiting**状态相当于在等待状态的基础上，加了一个超时限制，比如通过sleep(long mills) / wait(long mills) 方法可以将线程置于**time_waiting**状态，当超时时间结束后，该线程会回到**running**状态。当线程调用同步方法，在没有获取到锁的情况下，线程将会进入到**blocked**状态。线程在执行**Runnable**的run方法之后，将会进入到**terminated**状态。

## 上下文切换

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

## 死锁

线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。、

**产生死锁必须具备的四个条件：**

- 互斥条件：该资源任意一个时刻只由一个线程占用。

- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

- 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**如何避免产生死锁？**

- **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。

- **破坏请求与保持条件** ：一次性申请所有的资源。

- **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

- **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

## sleep() & wait()

- `sleep()`方法不会释放锁，`wait()`方法会释放锁
- 两者都可以暂停线程的执行
- `wait()`通常被用于线程之间的交互/通信，`sleep()`通常用于暂停线程的执行
- `wait()`方法调用后，线程不会自动苏醒，需要别的线程在同一个对象上调用`notify()/notifyAll()`方法；`sleep()`方法执行结束后，线程会自动苏醒。使用`wait(long timeout)`超时后线程会自动苏醒

## 调用 start() 方法会执行 run() 方法，为什么不能直接调用 run() 方法？

new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**

## synchronized 关键字

`synchronized`**关键字解决的是多个线程之间访问资源的同步性问题**，`synchronized`**关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程在执行。**

> 在早期 Java 版本中，`synchronized`属于**重量级锁**，效率较为低下

### synchronized 关键字的主要的三种使用方法

**1.修饰实例方法：**作用于当前对象实例加锁，进入同步代码前要获得**当前对象实例的锁**

~~~java
synchronized void method {
    //	业务代码块
}
~~~

**2.修饰静态方法：**也就是给当前类加锁，会作用于类的所有对象实例，进入同步代码前要获得当前类的的锁，因为静态成员不属于任何一个实例对象，是类成员（static表示这是该类的一个静态资源，不管new了多少个对象，只有这一个）

线程A调用一个实例对象的非静态`synchronized`方法，而线程B需要调用这个实例对象所属类的静态`synchronized`方法，是允许的。因为**访问静态`synchronized`方法占用的锁是当前类的锁，而访问非静态`synchronized`方法占用的锁是当前实例对象的锁。**

~~~java
synchronized void static method {
    //	业务代码块
}
~~~

**3.修饰代码块：**指定加锁的对象，给指定的对象/类加锁。

- `synchronized(this|object)`表示进入同步代码块需要获得给定对象的锁

- `synchronized(类.class)`表示进入同步代码之前要获得当前类的锁

~~~java
synchronized(this) {
    //	业务代码块
}
~~~

**总结：**

- `synchronized` 关键字加到 `static` 静态方法和 `synchronized(class)` 代码块上都是给类加上锁
- `synchronized` 关键字加到实例方法上是给实例对象加上锁
- 尽量不要使用 `synchronized(String s)` 因为 JVM 中，字符串常量池具有缓存功能！！

### 构造方法可以使用 synchronized 关键字修饰吗？

**不能，构造方法本上就属于线程安全的，不存在同步的构造方法一说**

### JDK 1.6 之后的 synchronized 关键字做了哪些优化？

偏向锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术，来减少锁操作的开销。

**锁的 4 种状态：**

- 无锁状态
- 偏向锁状态
- 轻量级锁状态
- 重量级锁状态

> 4 种状态会随着竞争的激烈而逐渐升级
>
> 锁可以升级，但是不可以降级，这种策略是为了提高获得锁和释放锁的效率

## volatile 关键字

在 JDK 1.2 之前，Java 的内存模型实现总是从**主存**（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存**本地内存**（比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成**数据的不一致**。

要解决这个问题，就需要把变量声明为**`volatile`**，这就指示 JVM，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。

所以，**`volatile` 关键字 除了防止 JVM 的指令重排 ，还有一个重要的作用就是保证变量的可见性。**

### 并发编程的三个重要特性

- **原子性：**一个操作或多次操作，要么所有操作都执行，要么都不执行，`synchronized`关键字可以保证代码片段的原子性
- **可见性：**当一个线程对共享变量进行了修改，那么其他线程都可以看到修改后的最新值，`volatile`关键字可以保证变量的可见性
- **有序性：**代码在执行的过程中，按照先后顺序依次执行，代码的执行顺序，未必就是编写时的顺序，`volatile`关键字可以禁止指令进行重排序优化

### synchronized & volatile 的区别

- `volatile`关键字是线程同步的轻量级实现，所以其性能比`synchronized`要好
- `volatile`只能作用于变量，`synchronized`还可以作用于方法和代码块
- `volatile`只能保证数据的可见性，不能保证数据的原子性。`synchronized`都可以
- `volatile`主要用于解决变量在多个线程之间的可见性
- `synchronized`主要用于解决多个线程之间访问资源的同步性

## ThreadLocal

通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。**如果想实现每一个线程都有自己的专属本地变量该如何解决呢？** JDK 中提供的`ThreadLocal`类正是为了解决这样的问题。 **`ThreadLocal`类主要解决的就是让每个线程绑定自己的值，可以将`ThreadLocal`类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。**

**如果你创建了一个`ThreadLocal`变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是`ThreadLocal`变量名的由来。他们可以使用 `get（）` 和 `set（）` 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。**

再举个简单的例子：

比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的。

**最终的变量是放在了当前线程的 `ThreadLocalMap` 中，并不是存在 `ThreadLocal` 上，`ThreadLocal` 可以理解为只是`ThreadLocalMap`的封装，传递了变量值。** `ThrealLocal` 类中可以通过`Thread.currentThread()`获取到当前线程对象后，直接通过`getMap(Thread t)`可以访问到该线程的`ThreadLocalMap`对象。

**每个`Thread`中都具备一个`ThreadLocalMap`，而`ThreadLocalMap`可以存储以`ThreadLocal`为 key ，Object 对象为 value 的键值对。**

### ThreadLocal 内存泄漏问题

`ThreadLocal` 中使用的 key 为 `ThreadLocal` 的弱引用，而 value 则是强引用，所以如果`ThreadLocal`没有被外部强引用的情况下，在垃圾回收的时候， key 会被清理掉，而 value 则不会，这样一来 `ThreadLocalMap` 中就会出现 key 为 null 的 Entry，这也就造成了内存泄漏的问题，value 永远无法被垃圾回收掉。`ThreadLocalMap` 在实现时已经解决了这个问题，在调用 `set()`, `get()`, `remove()` 方法时，会清理掉 key 为 null 的记录。

## 线程池

### Runnable 接口 &  Callable 接口

**多线程实现方式：**

- 继承 `Thread` 类
- 实现 `Runnable` 接口
- 实现 `Callable` 接口
- 通过线程池创建线程

`Runnable`自 Java 1.0 以来一直存在，但`Callable`仅在 Java 1.5 中引入,目的就是为了来处理`Runnable`不支持的用例。**`Runnable` 接口**不会返回结果或抛出检查异常，但是**`Callable` 接口**可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **`Runnable` 接口**，这样代码看起来会更加简洁。

## 乐观锁 & 悲观锁

### 悲观锁

总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（**共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程**）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中`synchronized`和`ReentrantLock`等独占锁就是悲观锁思想的实现。

### 乐观锁

总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。**乐观锁适用于多读的应用类型，这样可以提高吞吐量**，像数据库提供的类似于**write_condition机制**，其实都是提供的乐观锁。在Java中`java.util.concurrent.atomic`包下面的原子变量类就是使用了乐观锁的一种实现方式**CAS**实现的。

### 使用场景

从上面对两种锁的介绍，我们知道两种锁各有优缺点，不可认为一种好于另一种，像**乐观锁适用于写比较少的情况下（多读场景）**，即冲突真的很少发生的时候，这样可以省去了锁的开销，加大了系统的整个吞吐量。但如果是多写的情况，一般会经常产生冲突，这就会导致上层应用会不断的进行retry，这样反倒是降低了性能，所以**一般多写的场景下用悲观锁就比较合适。**

### 乐观锁常见的两种实现方式

**1.版本号**

一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加一。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。

**2. CAS 算法**

即**compare and swap（比较与交换）**，是一种有名的**无锁算法**。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。**CAS算法**涉及到三个操作数

- 需要读写的内存值 V
- 进行比较的值 A
- 拟写入的新值 B

当且仅当 V 的值等于 A时，CAS通过原子方式用新值B来更新V的值，否则不会执行任何操作（比较和替换是一个原子操作）。一般情况下是一个**自旋操作**，即**不断的重试**。

### 乐观锁的缺点

**1. ABA 问题**

如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然是A值，那我们就能说明它的值没有被其他线程修改过了吗？很明显是不能的，因为在这段时间它的值可能被改为其他值，然后又改回A，那CAS操作就会误认为它从来没有被修改过。这个问题被称为CAS操作的 **"ABA"问题。**

JDK 1.5 以后的 `AtomicStampedReference` 类就提供了此种能力，其中的 `compareAndSet `方法就是首先检查当前引用是否等于预期引用，并且当前标志是否等于预期标志，如果全部相等，则以原子方式将该引用和该标志的值设置为给定的更新值。



**2.循环时间长、开销大**

**自旋CAS（也就是不成功就一直循环执行直到成功）如果长时间不成功，会给CPU带来非常大的执行开销。** 如果JVM能支持处理器提供的pause指令那么效率会有一定的提升，pause指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使CPU不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起CPU流水线被清空（CPU pipeline flush），从而提高CPU的执行效率。

## Java 中对象的创建

**1.类加载检查**

虚拟机先遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已经被加载过、解析和初始化过，如果没有，那必须先执行响应的类加载过程。

**2.分配内存**

在类加载检查完成后，接下来虚拟机将为新生对象分配内存，对象所需的内存大小在类加载检查完成时就已经确定，为对象分配空间等同于在堆内存中划分一块区域。分配的方式有 **指针碰撞** 和 **空闲列表** 两种，选择哪种分配方式取决于堆内存是否规整，而堆内存是否规整取决于垃圾回收器是否有整理压缩的功能。

**内存分配的两种方式**

堆内存是否规整取决于垃圾回收机制是 **标记-清除** 还是 **标记-整理**。

- **指针碰撞**
  - 适用场合：堆内存规整，即没有内存碎片的情况下
  - 原理：使用过的内存整合到一边，没有使用过的放在另一边，中间有一个分界值指针，只需要向没用过的内存方向将该指针移动所需内存大小即可
  - GC 收集器：Serial, ParNew
- **空间列表**
  - 适用场合：堆内存不规整的情况下
  - 原理：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块足够大的内存来划分给对象实例，最后更新内存记录列表
  - GC 收集器： CMS

**3.初始化零值**

内存分配完成后，虚拟机将分配到的内存空间都初始化为零值，这一步操作保证了对象的实例字段在 Java 代码中可以不赋值就直接使用，程序能访问到这些字段的数据类型所对应的零值

**4.设置对象头**

初始化零值完成之后，虚拟机要对对象进行必要的设置，将设置的一些信息存放在对象头中

**5.执行 init 方法**

上述工作完成之后，执行完 new 指令之后，接着执行 init 方法，这样对象才算完全产生出来