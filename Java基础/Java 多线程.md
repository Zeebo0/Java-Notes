# Java 多线程

## 线程&进程

### 什么是进程？

进程时程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的，系统运行一个程序，就是一个进程从创建、运行到消亡的过程。

在 Java 中，当我们启动 main 函数时，其实就是启动了一个 JVM 进程，而 main 函数所在的线程就是这个进程中的主线程。

### 什么是线程？

线程和进程相似，但线程是一个比进程更小的执行单位。一个进程在执行过程中，可以产生多个线程。与进程不同的是**同类的多个线程共享进程的 堆 和 方法区 的资源**，但每个线程都有自己的 **程序计数器、虚拟机栈 和 本地方法栈**，所以系统在产生一个线程或者在多个线程之间切换时，负担要比进程小很多，因此，线程被称为 **轻量级的进程**。

> **一个 Java 程序的运行是 main 线程和多个其他线程同时运行**

## 线程和进程的关系和区别，以及各自的优缺点

### Java 内存区域

Java 虚拟机在执行 Java 程序过程中会把它管理的内存划分称为若干个不同的数据区域，这些组成部分一些是线程私有的，其他的则是线程共享的。

**线程私有的：**

- 程序计数器
- 虚拟机栈
- 本地方法栈

**线程共享的：**

- 堆
- 方法区
- 直接内存

#### 程序计数器

程序计数器的主要有两个作用：

- 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，例如：顺序执行、选择、循环、异常处理等操作
- 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候，虚拟机能够知道上次执行到哪里

> **程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程创建而被创建，随着线程的结束而死亡**

**程序计数器为什么是私有的？**

程序计数器私有主要是为了**线程切换后能恢复到正确的执行位置**。

#### 虚拟机栈

**Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。** （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）

**局部变量表主要存放了编译器可知的各种数据类型**（boolean、byte、char、short、int、float、long、double）、**对象引用**（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。

**JVM 会出现两种异常：**

- **StackOverFlowError：**若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机的栈的最大深度的时候，就会抛出该异常。
- **OutOfMemoryError:** 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时用完了，无法再动态扩展了，此时会抛出该异常。

> **Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型。**

#### 本地方法栈

和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。

方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。

**虚拟机栈和本地方法栈为什么是私有的？**

- **虚拟机栈：** 每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。
- **本地方法栈：** 和虚拟机栈所发挥的作用非常相似，区别是： **虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。**

所以，为了**保证线程中的局部变量不被别的线程访问到**，虚拟机栈和本地方法栈是线程私有的。

#### 堆

堆 是 Java 虚拟机所管理的内存中最大的一块区域，是所有线程共享的，在虚拟器启动时就创建。**此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都存放在这里**

堆 是垃圾回收器管理的主要区域，因此也被称作为 **GC堆**。堆 还可以细分为 **新生代** 和 **老生代** 

进一步划分的目的就是为了更好地回收内存空间，更快地分配内存。

> **JDK 1.8 中移除了永久代，取而代之的是一个叫元空间的区域，永久代使用的是堆内存的空间，而元空间使用的是物理内存，直接受到本机的物理内存的限制**

#### 方法区

**方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。**

> **相对而言，垃圾回收在这个区域较少出现，但不意味着进入了方法区后就会永久存在**

#### 运行时常量池

运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。

**JDK 1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。**

#### 直接内存

JDK 1.4中新加入的 **NIO(New Input/Output) 类**，引入了一种基于**通道（Channel）** 与**缓存区（Buffer）** 的 I/O 方式，它可以直接使用Native函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为**避免了在 Java 堆和 Native 堆之间来回复制数据**。

本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。

#### 总结

线程是进程划分成更小的运行单位，线程和进程最大的不同在于基本上各进程都是相互独立的，但是同一进程的不同线程之间，可能会相互影响。线程的执行开销较小，但是管理和维护较为困难，进程恰好与之相反。

堆 和 方法区 是所有线程共享的资源，其中 堆 是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要存放已被加载的类的信息、常量、静态变量、即时编译器编译后的代码等数据。

## 并发 & 并行

- **并发：**同一时间段内，多个任务都在执行
- **并行：**单位时间内，多个任务同时执行

## 多线程带来的问题？

并发编程的目的是为了提高程序执行的效率和运行速度，但是并发编程并不是总能提高程序的的执行速度，而且有可能带来内存泄漏、死锁、线程不安全等问题。

## 线程的声明周期和状态

|   状态名称   | 说明                                                         |
| :----------: | :----------------------------------------------------------- |
|     new      | 初始状态，线程被构建，但是还没有调用 start 方法              |
|   runnable   | 运行状态，Java 线程将操作系统中就绪和运行的两种状态统称为运行中 |
|   blocked    | 阻塞状态，表示线程阻塞于锁                                   |
|   waiting    | 等待状态，表示线程进入等待状态，进入该状态表示当前线程需要等待其他线程做出特定动作 |
| time_waiting | 超时等待状态，不同意等待状态，可以在指定时间自行返回         |
|  terminated  | 终止状态，表示当前线程已经执行完毕                           |

线程创建之后处理**new**状态，调用start方法开始运行，线程这时候处于**ready**状态，可运行状态的线程或者CPU时间片之后就处于**running**状态。当线程执行wait方法之后，线程进入**waiting**状态，进入等待转台的线程，需要依靠其他线程的通知，才能进入运行状态，而**time_waiting**状态相当于在等待状态的基础上，加了一个超时限制，比如通过sleep(long mills) / wait(long mills) 方法可以将线程置于**time_waiting**状态，当超时时间结束后，该线程会回到**running**状态。当线程调用同步方法，在没有获取到锁的情况下，线程将会进入到**blocked**状态。线程在执行**Runnable**的run方法之后，将会进入到**terminated**状态。

## 上下文切换

多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。

概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。**任务从保存到再加载的过程就是一次上下文切换**。

上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。

Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。

## 死锁

线程死锁描述的是这样一种情况：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。、

**产生死锁必须具备的四个条件：**

- 互斥条件：该资源任意一个时刻只由一个线程占用。

- 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。

- 不剥夺条件:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。

- 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。

**如何避免产生死锁？**

- **破坏互斥条件** ：这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。

- **破坏请求与保持条件** ：一次性申请所有的资源。

- **破坏不剥夺条件** ：占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。

- **破坏循环等待条件** ：靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。

## sleep() & wait()

- `sleep()`方法不会释放锁，`wait()`方法会释放锁
- 两者都可以暂停线程的执行
- `wait()`通常被用于线程之间的交互/通信，`sleep()`通常用于暂停线程的执行
- `wait()`方法调用后，线程不会自动苏醒，需要别的线程在同一个对象上调用`notify()/notifyAll()`方法；`sleep()`方法执行结束后，线程会自动苏醒。使用`wait(long timeout)`超时后线程会自动苏醒

## 调用 start() 方法会执行 run() 方法，为什么不能直接调用 run() 方法？

new 一个 Thread，线程进入了新建状态;调用 start() 方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start() 会执行线程的相应准备工作，然后自动执行 run() 方法的内容，这是真正的多线程工作。 而直接执行 run() 方法，会把 run 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。

**总结： 调用 start 方法方可启动线程并使线程进入就绪状态，而 run 方法只是 thread 的一个普通方法调用，还是在主线程里执行。**